新しくしました。

// んー、出すときと消すときはエフェクトとか工夫したいかな・・GLSL辺り使って。

2020/07/02.
とりあえずクラス化はおいておいて、今の状況でseed組み立てする際の完璧なマニュアルを作る所から始めたい。
基本的にはparseとexecuteを見ればいいんだけどね・・。
基本1
seedの構成。グローバル・アクション・ショートの3部構成からなり、それ以外にはない。
グローバル：主にシードの初期設定、ユニットノードと呼ばれる一番最初に一つだけ用意されるユニットがあるんだけど、
           それの特徴などを記述するのに使われるわね。あとは背景色やテキストの色なんかも書けたりするんだっけか。
           （SystemのsetPatternのところでparsePatternSeedが実行されるんだけど、そこでbgColorとinfoColorがあると
           背景色や情報の色が変わる。これは無くてもデフォルトが設定されるので問題ないが。）
           問題はこのデフォルトのところね。やっぱ毎回なんでもかんでも書くと煩雑になるからデフォルトがある。
           だからデフォルトが何かを理解するのが大事なのね。
（ユニット：エネミーとブレットの概念を統一したもの。最初にひとつだけユニットがデフォルトで用意されるが、これをノードユニットという。
これを非表示にすることで、ユニットがユニットを生成するメソッドで敵配置を行なったり、弾丸の発射、及び発射した弾丸の分裂などを
表現することができる。）
アクション：プロパティがいくつも並んでいてそれぞれ配列となっている。
           まず"main"プロパティがあり、付随するプロパティが並ぶ。mainにはノードユニットの挙動を記述する。最初から最後まですべて書かれて
           いるので、複雑だったりするとすごく長くなる。というかこれを削るためにいろいろ工夫したからこんな長くなったのよね。
           オブジェクトがいくつも並んでいてこれらをコマンドブロックという。コマンドブロックはパースで翻訳されてコマンドオブジェクトとなり、
           ユニットのアクションプロパティに格納される。そしてユニットのexecuteメソッドでそれを順繰りに実行する感じかしら。
           そうだ、interpretCommandで解釈したら終わりだっけ。
           省略記法あみだしたときにいろいろ複雑になった経緯がある。書きやすいってのはそういうこと。
           コマンドブロックは最初にあるプロパティが用意されていてそのあとつらつら～ってなってる。このinitialPropertyはgetTopKeyで
           取得されて解釈する際のカギとなり、これ以降の記述の仕方を柔軟にする役割を果たしている。ただそれによりやたらifが多くなってしまっている。
           これを簡略化しようっていう試みがすなわち「クラス化計画」だったが今は頓挫して凍結中。(executeのifが多すぎるのも案件だった)
           main以外のプロパティはmain内のコマンドブロックで下位ユニット（ノードユニット、またはそれが生成するユニットが生成するすべてのユニット）
           にセットするアクションの内容に関するもの。これ紛らわしいんだけど、shortにもいろいろ出てきてそれはshortの方が参照される。
           セットするアクションはアクション配列としての形式を保っていないといけないのは当たり前。
           ショートについては後で書く。
  ショート：要するに辞書。同じことをいくつも書きたくない場合や、長すぎて分けないと流れが分かりづらくなる場合とかに使う。
           コマンドブロックの羅列がキーワードプロパティに属している形。
           ドル記法について。コマンドブロックでshortとあるものを解釈するときに、プロパティがshortの他にもあると、
           それを参照してその値で置き換わる、要するに関数の引数みたいなものね。(interoretNestedData参照)

  おわりです
  あとはコマンドブロックが何を意味するか、デフォルトは何か、その辺。
  デフォルトが何かわかれば、それはコマンドでしか変化しないから、自由に組んでいけるでしょ。
  コンフィグでデフォルトをいじれたりしたら楽しそうだけど夢の世界の話ね。

  パースの手順とかデフォルトとかユニットのプロパティは何があってそれぞれのデフォルトは何かetcetcetc......
  ユニットのプロパティ一覧
  基本的にイニシャライズで設定されてるものが多い。同時にデフォも見れちゃうからちゃんと見ていくことに・・んー、長い。

  どうでもいいけど、shotActionのclearって廃止したのね・・じゃあもうshotActionのバリューでいいじゃんって思うよね。
  clearはなくしたんよね・・結局ショットに何かしらのアクションを付与する場合、それを解除する機会が基本・・
  あーでもそうか、んー、まあ敵の挙動とかに使われるんだけど、違う挙動を定義するならいちいちclearしないで上書きするでしょ、そういうことです。

  ユニットのプロパティ

  loopCounterがやたら複雑で、これも相当、相当悩んだ結果こうなったんですよね・・
  構造的にはstackと同じことをしている。というか多重ループ構造がまさにstackで扱うのにうってつけの形なので。
  こういうの・・[[これを3回][これを2回]これらを10回]
  例示の方が早いか。たとえば{fire:""}だとfireのあとは抜けずに次の処理へ向かうことになってるから、
  {catch:"a"}{fire:""}{loop:INF, back:"a"}だとfireが無限に繰り返されてしまうわけね。loopはループを抜けないので。
  これを「毎フレーム1発ずつ」にするには、
  {catch:"a"}{fire:""}{wait:1}{loop:INF, back:"a"}
  とすればいい。{fire:""}のあとはすぐ{wait:1}にいくが、これによりwaitではカウンターを1進めて1がlimitでこれに達するので次へ向かうが、
  waitは常に処理をいったん打ち切って次フレームに向かうので、これにより1拍置くことができて毎フレーム1発が実現する。
  また、2フレームに1発なら{wait:2}とすればいい。このように1や2で整合性が取れるのでそのような処理にしている。
  またさらに、以前だとこの手の変更でbackのところのいくつ戻るかってのをいちいち書き換えてた（先頭に戻る場合は-1という特別な略記法があったけど
  途中だと使えないでしょ・・）ので大変面倒だったがこのように文字列を使えば挿入するだけで済むから楽ちん！色々改良を重ねたのよ・・・。

  ほんとはもっとね・・{loop:INF, action:[{fire:""}, {wait:1}]} とかしてもよさそうだけどね。
  ただ入れ子構造は始まりと終わりを見つけるのがしんどいから今のcatch～back方式の方がだいぶいいと思う。
  pythonのインデント表記とかならもっといいかも？
  loop:INF
    fire:""
    wait:1
  みたいな。？？
  loop:INF
    loop:3
      shotDirection:["rel", 90]
      fire:""
      wait:2
    loop:8
      shotDirection:["rel", -90]
      fire:""
      wait:5
  とかなんかそういうの。

  話を戻そう
  要はこの流れを他のプログラムでもやりたいんだけどっていう。
  パースの所はlineやradialの展開を除けば別にSTGじゃなくても使える。
  解釈部分まではすべて同じようにできる。
  解釈の所（interpret以下）とそれを元にexecuteするところだけ差し替えればいい。

  コマンドブロックはもっと自由でいい。
  {bgColor:"red"}
  があったらそのユニットは背景の色を変えるとか。
  {bgGrad:["red", "blue", 60]}
  があったらそのユニットは背景色を60フレーム掛けてredからblueまで自然に変化させる。イージングしてもいい。
  {parallel:{span:60, x:[20, 100], y:[100, 20], alpha:[0, 255], easing:"inExpo"}}
  があったらxを20から100までyを100から20までalphaを0から255まで変化させてイージングはinExpoで、みたいな。
  コマンドブロックを元にしてinterpretでコマンドオブジェクトが作られてactionArrayの各成分がそれで置き換わり
  省略がある場合はそこも入れ子になって
  最終的に放り込まれる感じ。
  もしくは・・・xとyのそれぞれについてスタートと停留点とゴールを定めるメソッドを用意して、それを元に動かすのであれば、
  そういうメソッドにすればコマンドを統一的に書けるね。alphaの0～255～255～0は共通だからいいとして。
  rotationAngleをいじるとか。サイズファクターもMAXをランダムで決めて・・線分なら長さ、正多角形などなら直径とか。半分にしてもいいけど。
  で、あとはファクターを0～1～1～0、固定。
  そこまで決めちゃうともう{appear:60, easing:"outExpo"}{wait:60}{disappear:60, easing:"inExpo"}でOKね。
  {set:{x:143, y:259, diffX:160, diffY:120, size:44, shape:"triangle"}}
  とかしてセットするユニットの形を定める感じ。で、{action:"routine"}からのroutine:{}{}{}（上の3つ）でいいんじゃない。
  さらにこれを{catch:"b"}{catch:"a"}{set:{.....}}{wait:1}{loop:20, back:"a"}{wait:180}{loop:INF, back:"b"}とかすれば完璧ね。
  できたじゃん。これを落とし込むだけだわね。

  {showText:"hello", x:20, y:40, color:"red", shadow:true, span:60}で・・・いいや、めんどくさい。

  // もうちょっとサンプルが要るわね・・。
  つまりプロトタイプ的な実験的な・・ああー、抽象化するにはこれだけだと弱いなって話。
  ていうか気持ちが戻らないからそこから始めないといけないのがほんとあれ。ああーーーー・・・・
  ああーーーーー
  ああーーーーー
  戻ってこい！！！
  めんどくさい。めんどくさい。めんどく・・・さい・・・・
